import { webSearchService, WebSearchResponse } from '../search/webSearchService'
import { aiService } from '../ai/aiService'
import { contentService } from '../database/contentService'
import { prisma } from '../database/prisma'

export interface AutoContentOptions {
  style?: 'professional' | 'casual' | 'technical' | 'creative'
  length?: 'short' | 'medium' | 'long'
  includeSources?: boolean
  maxSearchResults?: number
  enableAutoGeneration?: boolean
}

export interface AutoGeneratedContent {
  id: string
  originalArticleId: string
  title: string
  content: string
  searchResults: WebSearchResponse
  generatedAt: Date
  style: string
  length: string
}

/**
 * Automated content generator that expands RSS articles using web search
 */
export class AutoContentGenerator {
  private readonly DEFAULT_OPTIONS: AutoContentOptions = {
    style: 'professional',
    length: 'medium',
    includeSources: true,
    maxSearchResults: 5,
    enableAutoGeneration: true
  }

  /**
   * Process a new RSS article and generate extended content
   */
  async processArticle(
    feedItemId: string,
    articleTitle: string,
    articleContent: string,
    userId: string,
    options: Partial<AutoContentOptions> = {}
  ): Promise<AutoGeneratedContent | null> {
    const config = { ...this.DEFAULT_OPTIONS, ...options }

    if (!config.enableAutoGeneration) {
      return null
    }

    try {
      console.log(`Auto-generating content for article: ${articleTitle}`)

      // Check if we already generated content for this article
      const existing = await this.getExistingContent(feedItemId)
      if (existing) {
        console.log(`Content already exists for article ${feedItemId}`)
        return existing
      }

      // Perform web search to gather additional context
      const searchQuery = webSearchService.createSearchQuery(articleTitle, this.extractKeywords(articleContent))
      const searchResults = await webSearchService.search({
        query: searchQuery,
        maxResults: config.maxSearchResults
      })

      if (searchResults.results.length === 0) {
        console.warn(`No search results found for: ${searchQuery}`)
        return null
      }

      // Generate extended content using AI
      const extendedContent = await this.generateExtendedContent(
        articleTitle,
        articleContent,
        searchResults,
        config
      )

      // Save the generated content
      const savedContent = await this.saveGeneratedContent(
        feedItemId,
        articleTitle,
        extendedContent,
        searchResults,
        userId,
        config
      )

      console.log(`Successfully generated content for article: ${articleTitle}`)
      return savedContent

    } catch (error) {
      console.error(`Failed to auto-generate content for article ${feedItemId}:`, error)
      return null
    }
  }

  /**
   * Generate extended blog post content using original article + web search results
   */
  private async generateExtendedContent(
    title: string,
    originalContent: string,
    searchResults: WebSearchResponse,
    options: AutoContentOptions
  ): Promise<string> {
    // Prepare search results for the AI prompt
    const searchContext = searchResults.results.map((result, index) =>
      `${index + 1}. **${result.title}** (${result.source})
   ${result.snippet}
   Source: ${result.url}`
    ).join('\n\n')

    const prompt = `Create an extended, comprehensive blog post based on the following RSS article and additional research.

**Original RSS Article:**
Title: ${title}
Content: ${originalContent.substring(0, 1000)}${originalContent.length > 1000 ? '...' : ''}

**Additional Research from Web Search:**
${searchContext}

**Requirements:**
- Write in a ${options.style} style
- Create a ${options.length || 'medium'} blog post (approximately ${this.getWordCount(options.length || 'medium')} words)
- Expand significantly on the original article using the research findings
- Include multiple perspectives and recent developments
- Add analysis and insights not present in the original article
- Structure with clear sections and subheadings
- Make it engaging and informative for readers
${options.includeSources ? '- Include citations to the research sources using [1], [2], etc.' : ''}

Focus on providing value beyond the original article by synthesizing information from multiple sources and adding expert analysis.`

    return await aiService.generateContent(prompt)
  }

  /**
   * Extract keywords from article content for better search
   */
  private extractKeywords(content: string): string[] {
    // Simple keyword extraction - extract nouns and important terms
    const words = content.toLowerCase()
      .replace(/[^\w\s]/g, ' ')
      .split(/\s+/)
      .filter(word => word.length > 4) // Focus on longer, more specific words
      .slice(0, 3) // Take top 3 keywords

    return words
  }

  /**
   * Get approximate word count for length option
   */
  private getWordCount(length: string): number {
    switch (length) {
      case 'short': return 800
      case 'medium': return 1500
      case 'long': return 2500
      default: return 1500
    }
  }

  /**
   * Check if content was already generated for this article
   */
  private async getExistingContent(feedItemId: string): Promise<AutoGeneratedContent | null> {
    // Check our custom table for auto-generated content
    // For now, we'll use a simple approach - check if there's content with this feed item as source
    try {
      const existingContent = await prisma.content.findFirst({
        where: {
          // This is a simplified check - in production, you'd have a proper relationship
          prompt: {
            contains: feedItemId
          }
        }
      })

      if (existingContent) {
        return {
          id: existingContent.id,
          originalArticleId: feedItemId,
          title: existingContent.title,
          content: existingContent.content,
          searchResults: { query: '', results: [], totalResults: 0, searchTime: 0 }, // Placeholder
          generatedAt: existingContent.generatedAt,
          style: existingContent.style,
          length: existingContent.length
        }
      }
    } catch (error) {
      console.warn('Error checking for existing content:', error)
    }

    return null
  }

  /**
   * Save the generated content to database
   */
  private async saveGeneratedContent(
    feedItemId: string,
    title: string,
    content: string,
    searchResults: WebSearchResponse,
    userId: string,
    options: AutoContentOptions
  ): Promise<AutoGeneratedContent> {
    // Create enhanced title
    const enhancedTitle = `Deep Dive: ${title}`

    // Save to content table with metadata
    const savedContent = await contentService.createContent({
      userId,
      title: enhancedTitle,
      content,
      style: options.style!,
      length: options.length!,
      model: 'llama3.2:3b', // Current model
      prompt: `Auto-generated from RSS article ${feedItemId} with web search research`
    })

    // Store search results metadata (in production, you'd create a separate table)
    const searchMetadata = {
      originalArticleId: feedItemId,
      searchQuery: searchResults.query,
      searchResultsCount: searchResults.results.length,
      searchTime: searchResults.searchTime
    }

    // Update content with metadata in the prompt field (temporary solution)
    await contentService.updateContent(savedContent.id, {
      prompt: JSON.stringify(searchMetadata)
    })

    return {
      id: savedContent.id,
      originalArticleId: feedItemId,
      title: enhancedTitle,
      content,
      searchResults,
      generatedAt: new Date(),
      style: options.style!,
      length: options.length!
    }
  }

  /**
   * Get auto-generation statistics
   */
  async getStats(userId: string) {
    // Get content generated in the last 30 days that was auto-generated
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)

    const autoGeneratedContent = await prisma.content.findMany({
      where: {
        userId,
        createdAt: {
          gte: thirtyDaysAgo
        },
        prompt: {
          contains: 'Auto-generated from RSS'
        }
      }
    })

    return {
      totalAutoGenerated: autoGeneratedContent.length,
      totalWords: autoGeneratedContent.reduce((sum, content) => sum + (content.wordCount || 0), 0),
      averageLength: autoGeneratedContent.length > 0
        ? autoGeneratedContent.reduce((sum, content) => sum + (content.wordCount || 0), 0) / autoGeneratedContent.length
        : 0
    }
  }
}

export const autoContentGenerator = new AutoContentGenerator()